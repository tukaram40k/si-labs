\newpage
\setcounter{page}{1}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}
\lhead{Rudenco Ivan FAF-232. Embedded Systems Laboratory Work Report.}

% \tableofcontents
\newpage

\section{Domain Analysis}

\subsection*{Purpose of the Work}
Familiarizing students with the use of the \texttt{STDIO} library for serial communication and implementing a simple application that controls an LED via text commands sent from a serial terminal.

\subsection*{Objectives of the Work}
\begin{itemize}
    \item Understanding the basic principles of serial communication.
    \item Using the \texttt{STDIO} library for text information exchange.
    \item Designing an application that interprets commands transmitted through the serial interface.
    \item Developing a modular solution with separate functionalities for peripheral control.
\end{itemize}

\subsection*{Technologies Used}

\subsubsection*{Standard Input/Output (STDIO)}

Standard Input/Output (STDIO) represents a standardized library framework for managing input and output operations in programming languages. Within embedded systems, STDIO offers an abstraction layer that enables developers to communicate with the system through formatted text input and output. The STDIO library commonly incorporates functions like printf() for formatted output and scanf() for formatted input. In embedded implementations, STDIO is frequently redirected to a serial interface (UART), facilitating communication between the microcontroller and a host computer through a terminal application.

\subsubsection*{Serial Communication (UART)}

Universal Asynchronous Receiver-Transmitter (UART) serves as a hardware communication protocol employed for asynchronous serial communication. UART transforms parallel data from the microcontroller into serial data for transmission and performs the reverse operation. It utilizes only two signal lines (TX for transmission and RX for reception) along with ground, making it optimal for connecting embedded systems to computers or other devices. UART communication is defined by configurable parameters including baud rate (commonly 9600, 115200, etc.), data bits (typically 8), parity bits, and stop bits.

\subsubsection*{GPIO (General Purpose Input/Output)}

General Purpose Input/Output (GPIO) pins constitute configurable digital pins on microcontrollers that can be programmed as either inputs or outputs. When configured as inputs, GPIO pins can detect the state of external devices such as buttons, switches, or sensors. When configured as outputs, they can control external components such as LEDs, relays, or digital interfaces. GPIO pins often incorporate internal pull-up or pull-down resistors to maintain stable logic levels when external components are not actively controlling the pin.

\subsubsection*{Arduino Platform}

Arduino is an open-source electronics platform built upon user-friendly hardware and software. It delivers a simplified development environment and a comprehensive collection of libraries that abstract many low-level hardware details. The Arduino platform encompasses various microcontroller boards (such as Arduino Uno, Arduino Mega 2560, etc.), an Integrated Development Environment (IDE), and a thorough software framework. Arduino boards are extensively utilized in education, prototyping, and hobby projects due to their accessibility and robust community support.

\subsection*{Problem Definition}
\begin{itemize}
    \item Configure the application to work with the \texttt{STDIO} library via the serial interface for text exchange through the terminal.
    \item Design an MCU-based application that receives commands from the terminal via the serial interface to set the state of an LED:
    \begin{itemize}
        \item \texttt{led on} for turning it on.
        \item \texttt{led off} for turning it off.
    \end{itemize}
    \item The system must respond with text messages confirming the command.
    \item Use the \texttt{STDIO} library for text exchange through the terminal.
\end{itemize}

\subsection*{Materials and Resources}
\subsubsection*{Hardware Components}
\begin{itemize}
    \item Microcontroller (Arduino Uno) - Main processing unit that executes the program controlling the LED via serial commands
    \item LED - Light-emitting diode used as output indicator to demonstrate the functionality of the serial communication
    \item $220\,\Omega$ Resistor - Current limiting resistor to protect the LED from excessive current that could damage it
    \item Breadboard - Prototyping platform for building and testing the circuit without permanent connections
    \item Jumper wires - Electrical connectors used to establish connections between components on the breadboard
    \item Power source (USB) - Provides the necessary voltage and current to operate the microcontroller and connected components
\end{itemize}

\subsubsection*{Software Resources}
\begin{itemize}
    \item Visual Studio Code with the PlatformIO extension installed - Integrated Development Environment (IDE) for writing, compiling, and uploading code to the microcontroller
    \item Serial terminal emulator - Software tool for sending and receiving text-based commands through the serial interface
    \item Hardware simulator (Wokwi with VScode extension) - Simulation environment for testing the circuit and code without physical hardware
\end{itemize}

\subsection{System Architecture Justification}

The implemented system follows a layered architecture that separates concerns and promotes modularity. Each layer serves a specific purpose and contributes to the overall functionality of the system:

\subsubsection{Presentation Layer (Serial Terminal)}
This layer consists of the serial terminal emulator that provides the user interface for interacting with the system. It allows users to send text-based commands ('led on', 'led off') to the microcontroller and receive feedback messages. The justification for this layer is that it provides a simple, accessible interface for controlling the hardware without requiring complex graphical interfaces or additional components.

\subsubsection{Application Logic Layer (Main Application)}
This layer contains the core business logic that processes incoming commands and determines the appropriate actions. It parses the received text commands, validates them, and calls the appropriate methods in the hardware abstraction layer. The justification for separating this logic is that it centralizes command processing and decision-making, making the system easier to maintain and extend with additional commands.

\subsubsection{Hardware Abstraction Layer (LedController Class)}
This layer encapsulates all hardware-specific operations related to LED control. It provides a clean interface for turning the LED on, off, and toggling its state, hiding the complexity of GPIO operations. The justification for this layer is that it decouples the application logic from hardware specifics, allowing for easier testing, maintenance, and potential porting to different hardware platforms.

\subsubsection{Communication Layer (IO Library)}
This layer handles the redirection of standard input/output to the serial interface, enabling text-based communication between the microcontroller and the host computer. The justification for this layer is that it abstracts the complexities of UART communication, allowing the rest of the application to use familiar STDIO functions while seamlessly communicating over the serial interface.

\subsubsection{Platform Layer (Arduino Framework)}
This layer provides the underlying hardware abstraction and basic services such as GPIO control, serial communication, and timing functions. The justification for leveraging this layer is that it provides a stable, tested foundation that handles low-level hardware details, allowing higher layers to focus on application-specific functionality.

This layered architecture ensures separation of concerns, improves maintainability, and facilitates testing of individual components.

\subsection{Case Study of Interactive Embedded Systems}

Interactive embedded systems represent a significant category of applications where real-time user interaction is essential. This laboratory work serves as a fundamental case study in developing such systems, demonstrating key principles and challenges inherent in interactive embedded design.

The implemented LED control system exemplifies several characteristics of interactive embedded systems:

\textbf{Real-time Response}: The system must respond promptly to user commands received via the serial interface. Delays in processing commands like 'led on' or 'led off' would degrade the user experience and potentially cause confusion about the system's state.

\textbf{Bidirectional Communication}: Unlike simple sensor systems that only output data, this system engages in bidirectional communication, receiving commands from the user and providing feedback through both the LED status and serial messages.

\textbf{State Management}: The system maintains an internal state (LED on/off) that must be synchronized with external user commands. Proper state management ensures consistency between user expectations and system behavior.

\textbf{Resource Constraints}: Operating on an Arduino Uno, the system must function within limited computational resources, memory, and power constraints typical of embedded systems. The efficient use of buffers and minimal processing requirements demonstrate good resource management.

\textbf{Reliability}: The system must operate reliably in potentially noisy environments where serial communication may experience interference. The implementation includes basic error handling to maintain stability despite imperfect conditions.

This case study highlights the importance of modular design in interactive embedded systems. The separation of concerns between communication handling, command parsing, and hardware control allows for easier debugging, testing, and maintenance. Additionally, the use of hardware abstraction layers enables the same application logic to potentially work with different types of output devices (not just LEDs) with minimal code changes.

The simplicity of the LED control system makes it an ideal educational example for understanding the complexities that arise in more sophisticated interactive embedded systems, such as home automation devices, automotive interfaces, or medical equipment with user controls.

\section{Design}

\subsection{Architecture Diagram}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/Architecture.png}
    \caption{System architecture diagram}
    \label{fig:architecture}
\end{figure}

\hspace{\parindent}\textbf{Serial Terminal}:
Interface for bidirectional communication between the Arduino and external devices, enabling real-time monitoring and command input via text-based commands.

\textbf{IO Namespace}: Redirects standard input/output streams to the Arduino's serial interface, establishing communication with a baud rate of 9600.

\textbf{LedDriver}: Hardware abstraction layer that provides an object-oriented interface for managing LED states (on/off/toggle) through GPIO pin manipulation.

\textbf{Arduino}: Microcontroller platform that executes program logic, manages GPIO pins, handles serial communication, and coordinates software-hardware interaction.

\textbf{LED}: Light-emitting diode controlled by digital output signals from the Arduino, acting as a visual indicator for system status.


\subsection{Flowchart Diagram}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{images/Flowchart.png}
    \caption{Flowchart Diagram}
    \label{fig:flowchart}
\end{figure}

The code implements a serial communication interface that allows controlling an LED through text commands. A LedController object is initialized for pin 7 to manage the LED. In the setup() function, the LED controller is initialized and STDIO is redirected to the serial port. In the loop() function, the code continuously checks for incoming serial data. When data is received, it parses commands in the format "LED on" or "LED off" (case-insensitive). The code validates the command and toggles the LED state accordingly, with appropriate feedback messages sent back through the serial interface to confirm the action or indicate errors.

\subsection{Electric Circuit Diagram}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/Electric.png}
    \caption{Circuit diagram}
    \label{fig:electric_circuit}
\end{figure}

\subsection{Project Structure}

The project follows a modular architecture with clearly defined components organized in separate directories:

\begin{itemize}
    \item \textbf{Main Source File} (\texttt{src/main.cpp}): Contains the main application logic that orchestrates the interaction between the serial communication module and the LED controller. It initializes the LED controller for pin 7, redirects STDIO to the serial port, and implements the command parsing and execution loop.

    \item \textbf{LED Driver Library} (\texttt{lib/LedDriver/}): Implements the hardware abstraction layer for LED control with:
    \begin{itemize}
        \item \texttt{LedController.h}: Header file defining the LedController class interface with methods for turning the LED on, off, toggling, and checking its state.
        \item \texttt{LedController.cpp}: Implementation file containing the concrete methods for controlling the LED via GPIO operations.
    \end{itemize}

    \item \textbf{IO Library} (\texttt{lib/IO/}): Handles the redirection of standard input/output to the serial interface with:
    \begin{itemize}
        \item \texttt{IO.h}: Header file declaring the IO namespace and its helper functions for serial communication.
        \item \texttt{IO.cpp}: Implementation file containing functions to redirect stdin/stdout to the Arduino's serial port at 9600 baud rate.
    \end{itemize}

    \item \textbf{Configuration Files}:
    \begin{itemize}
        \item \texttt{platformio.ini}: PlatformIO project configuration specifying the target board (Arduino Uno), platform (atmelavr), and framework (Arduino).
        \item \texttt{wokwi.toml}: Configuration file for the Wokwi simulator environment.
    \end{itemize}

\end{itemize}

\section{Results}

The implemented system demonstrates a serial communication interface that allows controlling an LED through text commands sent from a serial terminal. The Arduino-based application receives commands in the format 'led on' or 'led off' via the STDIO library, processes them, and updates the LED state accordingly. The system provides visual feedback through the LED and textual confirmation through the serial interface, verifying successful command execution. \\

Below are shown screenshots of compiling the code and running the simulation.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/s0.png}
    \caption{Building the project}
    \label{fig:s0}
\end{figure}

This screenshot shows what happens after pressing the Build command. The code is compiled and ready to be uploaded.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/s1.png}
    \caption{Wokwi setup in VSCode}
    \label{fig:s1}
\end{figure}

This screenshot shows the simulation setup. It uses Wokwi extension for vscode. When the simulation starts, a serial terminal opens, and the program can be interacted with. it prints message "Ready" and is accepting commands.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/s2.png}
    \caption{Simulation after LED ON command}
    \label{fig:s2}
\end{figure}

This screenshot shows what happens after user inputs LED ON. The LED lights up, and the system prints confirmation message.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/s3.png}
    \caption{Simulation after LED OFF command}
    \label{fig:s3}
\end{figure}

This screenshot shows what happens after user inputs LED OFF. The LED turns off, and the system prints confirmation message.

\section{Conclusions}

\subsection{System Performance Analysis and Limitations}

The implemented system demonstrates effective serial communication between the Arduino microcontroller and a host computer using the STDIO library. The solution successfully processes text-based commands ('led on' and 'led off') through the serial interface, providing immediate visual feedback via the LED and textual confirmation through the serial monitor.

Performance analysis reveals that the system responds reliably to commands with minimal latency. The modular design separates concerns effectively: the IO namespace handles serial communication, the LedController class manages hardware abstraction, and the main application logic orchestrates the interaction between these components.

However, several limitations have been identified:
\begin{itemize}
    \item The command parsing mechanism is case-sensitive in its current form (though the code handles both uppercase and lowercase variations of 'LED' and 'on/off', it may miss other variations)
    \item Buffer sizes for input commands are fixed, which could lead to overflow issues with longer-than-expected inputs
    \item The system lacks error handling for malformed commands beyond basic validation
    \item No timeout mechanism exists for serial input, potentially causing the system to hang if incomplete commands are sent
    \item The scanf function used for input parsing could be vulnerable to buffer overflow attacks in a production environment
\end{itemize}

\subsection{Improvement Proposals}

Based on the identified limitations, the following improvements could enhance the system:

\begin{itemize}
    \item Implement dynamic buffer allocation or more robust string handling to prevent overflow issues
    \item Add timeout mechanisms for serial input to prevent hanging
    \item Enhance command parsing to handle a wider variety of command formats and improve error recovery
    \item Introduce command history and validation mechanisms to improve user experience
    \item Add checksum or CRC verification for improved data integrity in noisy environments
    \item Implement a more sophisticated state machine to handle complex command sequences
    \item Add logging capabilities for debugging and monitoring purposes
\end{itemize}

\subsection{Laboratory Work Results}

The laboratory work successfully achieved all defined objectives. The simulation results demonstrate that the system correctly interprets and executes commands sent via the serial interface. The Wokwi simulation environment proved effective for testing and validating the implementation without requiring physical hardware. The simulation results clearly show the system's ability to transition between different states based on received commands, confirming the reliability of the implemented solution.

\subsection{Real-World Application Impact}

The technologies explored in this laboratory work have significant implications for real-world embedded systems applications. Serial communication remains a fundamental aspect of embedded system development, serving as the backbone for device configuration, debugging, and control in numerous applications.

The modular design approach demonstrated here is directly applicable to industrial IoT devices, home automation systems, and embedded controllers where remote monitoring and control are essential. The STDIO library abstraction allows for easy adaptation of the same codebase to different communication interfaces (Bluetooth, WiFi, Ethernet) with minimal changes to the core application logic.

Furthermore, the hardware abstraction layer concept exemplified by the LedController class promotes code reusability and maintainability, which are critical factors in commercial embedded system development. This approach enables rapid prototyping and deployment across different hardware platforms while maintaining consistent software interfaces.

The skills developed through this exercise are foundational for careers in embedded systems engineering, where similar communication protocols and design patterns are widely employed in automotive, aerospace, medical device, and consumer electronics industries.

\section{Note on AI use}
During the drafting of this report, the author used Qwen for consolidating content. The resulting information was reviewed, validated, and adjusted according to the laboratory work requirements.